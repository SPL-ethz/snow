

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ethz_snow.snowflake &mdash; ethz_snow 1.1.0.post1.dev34+ga1dec07.d20230707 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="ethz_snow 1.1.0.post1.dev34+ga1dec07.d20230707 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> ethz_snow
          

          
          </a>

          
            
            
              <div class="version">
                1.1.0.post1.dev34+ga1dec07.d20230707
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/modules.html">Module Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ethz_snow</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>ethz_snow.snowflake</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ethz_snow.snowflake</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implement Snowflake class.</span>

<span class="sd">This module contains the Snowflake class used to run simulations</span>
<span class="sd">of water nucleation in vials.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">ethz_snow.operatingConditions</span> <span class="kn">import</span> <span class="n">OperatingConditions</span>
<span class="kn">from</span> <span class="nn">ethz_snow.constants</span> <span class="kn">import</span> <span class="n">calculateDerived</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c1"># import matplotlib.pyplot as plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">from</span> <span class="nn">.__init__</span> <span class="kn">import</span> <span class="n">__citation__</span><span class="p">,</span> <span class="n">__bibtex__</span>

<span class="n">HEATFLOW_REQUIREDKEYS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;ext&quot;</span><span class="p">,</span> <span class="s2">&quot;s0&quot;</span><span class="p">)</span>
<span class="n">VIAL_GROUPS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;corner&quot;</span><span class="p">,</span>
    <span class="s2">&quot;edge&quot;</span><span class="p">,</span>
    <span class="s2">&quot;core&quot;</span><span class="p">,</span>
    <span class="s2">&quot;side&quot;</span><span class="p">,</span>
    <span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="s2">&quot;center&quot;</span><span class="p">,</span>
<span class="p">)</span>  <span class="c1"># center will be deprecated</span>


<div class="viewcode-block" id="Snowflake"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake">[docs]</a><span class="k">class</span> <span class="nc">Snowflake</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class to handle a single Stochastic Nucleation of Water simulation.</span>

<span class="sd">    More information regarding the equations and their derivation can be found in</span>
<span class="sd">    &quot;Stochastic shelf-scale modeling framework for the freezing stage in</span>
<span class="sd">    freeze-drying processes&quot;, Deck, Ochsenbein, and Mazzotti (2022),</span>
<span class="sd">    Int J Pharm, 613, 121276, https://doi.org/10.1016/j.ijpharm.2021.121276.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        configPath (Optional[str]): The path of the (optional) custom config yaml.</span>
<span class="sd">        const (dict): A dictionary of constants to be used.</span>
<span class="sd">        dt (float): Time step.</span>
<span class="sd">        H_ext (np.ndarray): External heat transfer vector.</span>
<span class="sd">        H_int (csr_matrix): Internal heat transfer matrix.</span>
<span class="sd">        H_shelf (np.ndarray): Shelf heat transfer vector.</span>
<span class="sd">        initIce (str, optional): Which formulation for the initial amount of ice</span>
<span class="sd">                formed to use (see docs). Can be &#39;direct&#39; or &#39;indirect&#39;.</span>
<span class="sd">                Defaults to &#39;indirect&#39;.</span>
<span class="sd">        k (dict): Heat transfer coefficients.</span>
<span class="sd">        N_vials (tuple): Number of vials in each dimension.</span>
<span class="sd">        N_vials_total (int): Total number of vials.</span>
<span class="sd">        opcond (OperatingConditions): Operating conditions of run.</span>
<span class="sd">        seed (int): Seed to be used in rng.</span>
<span class="sd">        simulationStatus (int): Status of simulation (0 = not run, 1 = run).</span>
<span class="sd">        solidificationThreshold (float): What sigma value constitutes a &#39;solid&#39;.</span>
<span class="sd">        stats (dict): Run statistics (nucleation time, etc.).</span>
<span class="sd">        T_k_0 (float): Initial temperature of vials.</span>
<span class="sd">        X_sigma (np.ndarray): Sigma state over time.</span>
<span class="sd">        X_T (np.ndarray): Temperature state over time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;ext&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;s0&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;s_sigma_rel&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">},</span>
        <span class="n">N_vials</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">7</span><span class="p">,</span>
            <span class="mi">7</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">),</span>  <span class="c1"># should this be part of operating conditions?</span>
        <span class="n">initialStates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;temp&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
        <span class="n">storeStates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">solidificationThreshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2021</span><span class="p">,</span>
        <span class="n">opcond</span><span class="p">:</span> <span class="n">OperatingConditions</span> <span class="o">=</span> <span class="n">OperatingConditions</span><span class="p">(),</span>
        <span class="n">configPath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">initIce</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;indirect&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a Snowflake object.</span>

<span class="sd">        Args:</span>
<span class="sd">            k (dict, optional): A dictionary containing the heat transfer coefficients.</span>
<span class="sd">                Must contain keys &#39;int&#39;, &#39;ext&#39;, &#39;s0&#39;.</span>
<span class="sd">                Defaults to {&quot;int&quot;: 20, &quot;ext&quot;: 20, &quot;s0&quot;: 20, &quot;s_sigma_rel&quot;: 0.1}.</span>
<span class="sd">            N_vials (Tuple[int, int, int], optional): Number of vials in each dimension.</span>
<span class="sd">                Defaults to ( 7, 7, 1).</span>
<span class="sd">            initialStates (dict): Initial states of the vials (temp and sigma).</span>
<span class="sd">            storeStates (Union[str, Sequence[str], Sequence[int], None]):</span>
<span class="sd">                Whether and for which vials to store states (temp, sigma).</span>
<span class="sd">                Defaults to None -&gt; Nothing stored.</span>
<span class="sd">            solidificationThreshold (float, optional): What sigma value is</span>
<span class="sd">                a &#39;solid&#39;. Defaults to 0.9.</span>
<span class="sd">            dt (float, optional): Time step size. Defaults to 2.</span>
<span class="sd">            seed (int, optional): Seed to use for rng. Defaults to 2021.</span>
<span class="sd">            opcond (OperatingConditions, optional): Operating conditions to apply.</span>
<span class="sd">                Defaults to OperatingConditions().</span>
<span class="sd">            configPath (Optional[str], optional): The location of a custom configuration</span>
<span class="sd">                file (in yaml format), used to update/overwrite the default settings.</span>
<span class="sd">            initIce (str, optional): Which formulation for the initial amount of ice</span>
<span class="sd">                formed to use (see docs). Defaults to &#39;indirect&#39;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If k is not a dict.</span>
<span class="sd">            ValueError: If k does not contain all necessary keys.</span>
<span class="sd">            ValueERror: If len(N_vials) is not 3.</span>
<span class="sd">            TypeError: If opcond is not of type operatingConditions.</span>
<span class="sd">            ValueError: If initialstates is malformed.</span>
<span class="sd">            NotImplementedError: If initialstates has non-scalar temp or non-None sigma.</span>
<span class="sd">            ValueError: If storeStates is not meaningful.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; Sf = Snowflake()</span>
<span class="sd">            &gt;&gt;&gt; Sf = Snowflake(Nvials=(4, 3, 1), dt = 5)</span>
<span class="sd">            &gt;&gt;&gt; Sf = Snowflake(storeStates = [&#39;edge_random_4&#39;, &#39;uniform.core.5&#39;])</span>
<span class="sd">            &gt;&gt;&gt; Sf = Snowflake(storeStates = (0, 4, 10))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N_vials</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># we exepct this to be immutable</span>
            <span class="n">N_vials</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">N_vials</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">N_vials</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of N_vials must be 3, was </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">N_vials</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span> <span class="o">=</span> <span class="n">N_vials</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 3D case, k_shelf can be missing</span>
            <span class="n">hflowKeys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">HEATFLOW_REQUIREDKEYS</span> <span class="k">if</span> <span class="n">elem</span> <span class="o">!=</span> <span class="s2">&quot;s0&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hflowKeys</span> <span class="o">=</span> <span class="n">HEATFLOW_REQUIREDKEYS</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input k must be of type dict. Was given </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">key</span> <span class="ow">in</span> <span class="n">k</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hflowKeys</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;A required key was missing from dictionary k, specifically &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">hflowKeys</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opcond</span><span class="p">,</span> <span class="n">OperatingConditions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Input opcond must be an instance of class OperatingConditions.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span> <span class="o">=</span> <span class="n">opcond</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span> <span class="o">=</span> <span class="n">solidificationThreshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_simulationStatus</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_H_int</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_ext</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_shelf</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">configPath</span> <span class="o">=</span> <span class="n">configPath</span>

        <span class="c1"># store the seed to look it up if need be</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>

        <span class="c1"># remember what N_vials was used to build heat flow matrices</span>
        <span class="c1"># so if it changes we know to rebuild them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">initialStates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initialStates</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span>
            <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;temp&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">initialStates</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;initialStates malformed. Must be None or dict with keys &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;&#39;temp&#39; (and &#39;sigma&#39;). Was </span><span class="si">{</span><span class="n">initialStates</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">initialStates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T_k_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">cooling</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>  <span class="c1"># C</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">],</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T_k_0</span> <span class="o">=</span> <span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span>  <span class="c1"># C</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">],</span> <span class="s2">&quot;__len__&quot;</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T_k_0</span> <span class="o">=</span> <span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">],</span> <span class="s2">&quot;__len__&quot;</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Currently can only deal with constant initial temp.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;sigma&quot;</span> <span class="ow">in</span> <span class="n">initialStates</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">initialStates</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Non-zero sigma initial state not implemented.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_emptyStore</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">storeStates</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">storeStates</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">storeStates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">storeStates</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Entries in storeStates must be &gt;0 &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;and &lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">storageMask</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">storeStates</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">storeStates</span><span class="p">]):</span>
                <span class="n">storageMasks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpretStorageString</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">storeStates</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">storageMasks</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;storeStates must be a sequence of all int or all str.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">storeStates</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">storageMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpretStorageString</span><span class="p">(</span><span class="n">storeStates</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">storeStates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_emptyStore</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span> <span class="o">=</span> <span class="n">storageMask</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initIce</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">initIce</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;direct&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">initIce</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;indirect&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;initIce must be a string equal to &#39;indirect&#39; or &#39;direct&#39;. &quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;But it was </span><span class="si">{</span><span class="n">initIce</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initIce</span> <span class="o">=</span> <span class="n">initIce</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">simulationStatus</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return simulation status of instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Simulation status. 0 = not run, 1 = run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_simulationStatus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_simulationStatus</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulationStatus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_int</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the internal heat transfer matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            csr_matrix: The internal heat transfer matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_int</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buildHeatflowMatrices</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_H_int</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the external heat transfer vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The external heat transfer vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_ext</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buildHeatflowMatrices</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_H_ext</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_shelf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the shelf heat transfer vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The shelf heat transfer vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_shelf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seedUsed</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buildShelfHeatFlow</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_H_shelf</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">N_vials_total</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return total number of vials in system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X_T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the temperature states.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array containing the vial temperatures over time.</span>
<span class="sd">                This is just a slice of _X!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">)),</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the sigma states.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array containing the vial sigmas over time.</span>
<span class="sd">                This is just a slice of _X!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">))</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">seed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get or set the random seed.</span>

<span class="sd">        Setting the seed value will initialize a new rng under the hood.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The seed of the Snowflake.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span>

    <span class="nd">@seed</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># best practice is now to store the rng in an object and pass it around</span>
        <span class="c1"># https://towardsdatascience.com/stop-using-numpy-random-seed-581a9972805f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># store the seed to look it up if need be</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># let H_shelf figure out whether it needs to be updated</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_shelf</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">configPath</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get configPath property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_configPath</span>

    <span class="nd">@configPath</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">configPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set configPath property.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">=</span> <span class="n">calculateDerived</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_configPath</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_interpretStorageString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">myString</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpret the storeState string.</span>

<span class="sd">        Returns the interpretation of the storeState string</span>
<span class="sd">        indicating which states should be stored in _X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">myString</span> <span class="o">=</span> <span class="n">myString</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span><span class="n">word</span> <span class="ow">in</span> <span class="n">myString</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">VIAL_GROUPS</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="s2">&quot;uniform&quot;</span><span class="p">]]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid vial group or key word used in storeStates.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">word</span> <span class="ow">in</span> <span class="n">myString</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">VIAL_GROUPS</span><span class="p">)]):</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">VIAL_GROUPS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">:</span>
                    <span class="n">storageMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVialGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">elif</span> <span class="p">(</span><span class="s2">&quot;random&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;uniform&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">):</span>
            <span class="c1"># assume vial group &#39;all&#39; is implied</span>
            <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;random&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;uniform&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">):</span>
            <span class="n">howMany</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="n">myString</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">howMany</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># unclear how many to pick, default is 10%</span>
                <span class="n">howMany</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">howMany</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">howMany</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">howMany</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">howMany</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;storeStates strings must contain one number at most.&quot;</span><span class="p">)</span>

            <span class="n">I_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">storageMask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;random&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">:</span>
                <span class="n">I_toStore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">I_candidates</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">howMany</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;uniform&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">:</span>
                <span class="n">stepSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I_candidates</span><span class="p">)</span> <span class="o">/</span> <span class="n">howMany</span><span class="p">))</span>
                <span class="n">I_fromCandidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">I_candidates</span><span class="p">),</span> <span class="n">stepSize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">I_toStore</span> <span class="o">=</span> <span class="n">I_candidates</span><span class="p">[</span><span class="n">I_fromCandidates</span><span class="p">]</span>
            <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">storageMask</span><span class="p">[</span><span class="n">I_toStore</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">storageMask</span>

<div class="viewcode-block" id="Snowflake.run"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the simulation.&quot;&quot;&quot;</span>
        <span class="c1"># clean up any potential old simulations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Obtain external temperature profile over time</span>
        <span class="n">T_shelf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">tempProfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">T_ext</span> <span class="o">=</span> <span class="n">T_shelf</span>  <span class="c1"># need to make a switch so that this can be decoupled - DRO XX</span>

        <span class="c1"># store stuff in local variables to reduce getter method calls</span>
        <span class="c1"># note that getter method handles the construction of the matrices</span>
        <span class="c1"># in case they haven&#39;t been initialized yet</span>
        <span class="n">H_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_int</span>
        <span class="n">H_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_ext</span>
        <span class="n">H_shelf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_shelf</span>

        <span class="c1"># constants</span>
        <span class="n">solid_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;solid_fraction&quot;</span><span class="p">]</span>
        <span class="n">cp_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;cp_s&quot;</span><span class="p">]</span>
        <span class="n">cp_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;cp_w&quot;</span><span class="p">]</span>
        <span class="n">cp_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;cp_i&quot;</span><span class="p">]</span>
        <span class="n">cp_solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;cp_solution&quot;</span><span class="p">]</span>
        <span class="n">depression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;depression&quot;</span><span class="p">]</span>
        <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span>
        <span class="n">beta_solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;beta_solution&quot;</span><span class="p">]</span>
        <span class="n">T_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;T_eq&quot;</span><span class="p">]</span>
        <span class="n">T_eq_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;T_eq_l&quot;</span><span class="p">]</span>
        <span class="c1"># T_init = self.const[&quot;T_init&quot;]</span>
        <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;hl&quot;</span><span class="p">]</span>
        <span class="n">kb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;kb&quot;</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;V&quot;</span><span class="p">]</span>

        <span class="n">N_timeSteps</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">t_tot</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># the total number of timesteps</span>
        <span class="n">N_vials_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span>

        <span class="c1"># Initial state of the system</span>
        <span class="c1"># initial temperature</span>
        <span class="n">T_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_k_0</span>  <span class="c1"># [C]</span>
        <span class="n">sigma_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">)</span>  <span class="c1"># (0 = liq, 1 = completely frozen)</span>

        <span class="c1"># Pre-allocate memory</span>
        <span class="c1"># our state matrix containing the entire history of the system</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">),</span> <span class="n">N_timeSteps</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_timeSteps</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">t_nucleation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
            <span class="n">T_nucleation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
            <span class="n">t_solidification</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">cnt</span><span class="p">):</span>
            <span class="n">k_CN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">cnt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k_CN</span> <span class="o">=</span> <span class="n">N_timeSteps</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Iterate over time steps</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_timeSteps</span><span class="p">):</span>

            <span class="n">T_shelf_k</span> <span class="o">=</span> <span class="n">T_shelf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">T_ext_k</span> <span class="o">=</span> <span class="n">T_ext</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="c1"># toc1_l = time.perf_counter()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emptyStore</span><span class="p">:</span>
                <span class="c1"># does not give a huge boost.</span>
                <span class="n">x_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">T_k</span><span class="p">,</span> <span class="n">sigma_k</span><span class="p">])</span>
                <span class="n">X</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">])]</span>

            <span class="c1"># calculate heatflows for all vials</span>
            <span class="n">q_k</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">H_int</span> <span class="o">@</span> <span class="n">T_k</span> <span class="o">+</span> <span class="n">H_ext</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_ext_k</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">)</span> <span class="o">+</span> <span class="n">H_shelf</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_shelf_k</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># [XXX] units? - DRO</span>

            <span class="c1"># a mask that is True where a vial is still fully liquid</span>
            <span class="n">liquidMask</span> <span class="o">=</span> <span class="n">sigma_k</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">solidMask</span> <span class="o">=</span> <span class="o">~</span><span class="n">liquidMask</span>  <span class="c1"># for convenience</span>
            <span class="c1"># SOLID(IFYING) VIALS</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">solidMask</span><span class="p">):</span>
                <span class="n">solidifiedMask</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_k</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span>
                    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_solidification&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_solidification&quot;</span><span class="p">][</span><span class="n">solidifiedMask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_nucleation&quot;</span><span class="p">][</span><span class="n">solidifiedMask</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># heat capacity of solidifying vials</span>
                <span class="c1"># a vector of cps for all solidifying vials</span>
                <span class="n">cp_sigma</span> <span class="o">=</span> <span class="n">solid_fraction</span> <span class="o">*</span> <span class="n">cp_s</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">solid_fraction</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">cp_i</span> <span class="o">-</span> <span class="n">cp_w</span><span class="p">)</span> <span class="o">+</span> <span class="n">cp_w</span>
                <span class="p">)</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">depression</span> <span class="o">*</span> <span class="n">mass</span> <span class="o">*</span> <span class="n">cp_sigma</span>

                <span class="n">deltaSigma</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">q_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span>
                    <span class="o">/</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                <span class="p">)</span>
                <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span> <span class="o">+</span> <span class="n">deltaSigma</span>
                <span class="c1"># assumption is that during solidification T = Teq</span>
                <span class="n">T_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_eq</span> <span class="o">-</span> <span class="n">depression</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]))</span>

            <span class="c1"># LIQUID VIALS</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">liquidMask</span><span class="p">):</span>
                <span class="n">T_k</span><span class="p">[</span><span class="n">liquidMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_k</span><span class="p">[</span><span class="n">liquidMask</span><span class="p">]</span> <span class="o">+</span> <span class="n">q_k</span><span class="p">[</span><span class="n">liquidMask</span><span class="p">]</span> <span class="o">/</span> <span class="n">hl</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                <span class="c1"># a mask that is True where the temperature is</span>
                <span class="c1"># below the equilibrium temperature</span>
                <span class="n">superCooledMask</span> <span class="o">=</span> <span class="n">T_k</span> <span class="o">&lt;</span> <span class="n">T_eq_l</span>
                <span class="c1"># a vial that is both liquid and supercooled can nucleate</span>
                <span class="n">nucleationCandidatesMask</span> <span class="o">=</span> <span class="n">liquidMask</span> <span class="o">&amp;</span> <span class="n">superCooledMask</span>
                <span class="c1"># the total number of nucleation candidates</span>
                <span class="n">n_nucleationCandidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nucleationCandidatesMask</span><span class="p">)</span>

                <span class="c1"># nucleation probabilities for candidates</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">)</span>
                <span class="n">diceRolls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">)</span>

                <span class="n">P</span><span class="p">[</span><span class="n">nucleationCandidatesMask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">kb</span> <span class="o">*</span> <span class="n">V</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_eq_l</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">[</span><span class="n">nucleationCandidatesMask</span><span class="p">])</span> <span class="o">**</span> <span class="n">b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                <span class="p">)</span>
                <span class="c1"># when we reach the timepoint of controlled nucleation</span>
                <span class="c1"># all vials (that thermodynamically can) nucleate</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">k_CN</span><span class="p">:</span>
                    <span class="n">P</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">frac_justCant</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nucleationCandidatesMask</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_vials_total</span>
                    <span class="k">if</span> <span class="n">frac_justCant</span> <span class="o">&gt;=</span> <span class="mf">0.1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;WARNING: A significant number of vials &quot;</span>
                                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">frac_justCant</span> <span class="o">*</span> <span class="mi">100</span><span class="si">:</span><span class="s2">4.1f</span><span class="si">}</span><span class="s2">%) &quot;</span>
                                <span class="o">+</span> <span class="s2">&quot;were not supercooled when controlled &quot;</span>
                                <span class="o">+</span> <span class="s2">&quot;nucleation triggered.&quot;</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">diceRolls</span><span class="p">[</span><span class="n">nucleationCandidatesMask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span>
                    <span class="n">n_nucleationCandidates</span>
                <span class="p">)</span>

                <span class="c1"># Nucleation</span>
                <span class="n">nucleatedVialsMask</span> <span class="o">=</span> <span class="n">nucleationCandidatesMask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">diceRolls</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">)</span>

                <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_nucleation&quot;</span><span class="p">][</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;T_nucleation&quot;</span><span class="p">][</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span>

                <span class="n">q0</span> <span class="o">=</span> <span class="p">(</span><span class="n">T_eq_l</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">])</span> <span class="o">*</span> <span class="n">cp_solution</span> <span class="o">*</span> <span class="n">mass</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initIce</span> <span class="o">==</span> <span class="s2">&quot;indirect&quot;</span><span class="p">:</span>
                    <span class="n">sigma_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">q0</span> <span class="o">/</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">beta_solution</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># LTD: referred to as &quot;direct&quot; approach</span>
                    <span class="c1"># this is the one used in the derivation of the manuscripts</span>
                    <span class="n">gamma_direct</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">mass</span> <span class="o">/</span> <span class="n">cp_solution</span>
                    <span class="n">B_direct</span> <span class="o">=</span> <span class="n">T_eq</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">+</span> <span class="n">gamma_direct</span>
                    <span class="n">C_direct</span> <span class="o">=</span> <span class="n">T_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">-</span> <span class="n">T_eq</span> <span class="o">+</span> <span class="n">depression</span>

                    <span class="n">sigma_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="n">B_direct</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B_direct</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">gamma_direct</span> <span class="o">*</span> <span class="n">C_direct</span><span class="p">)</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma_direct</span><span class="p">)</span>

                <span class="c1"># assumption is that during solidification T = Teq</span>
                <span class="n">T_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_eq</span> <span class="o">-</span> <span class="n">depression</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigma_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">X</span>  <span class="c1"># store the state matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="n">t</span>  <span class="c1"># store the time vector</span></div>

<div class="viewcode-block" id="Snowflake.nucleationTimes"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.nucleationTimes">[docs]</a>    <span class="k">def</span> <span class="nf">nucleationTimes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">fromStates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return array of nucleation times.</span>

<span class="sd">        Args:</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>
<span class="sd">            fromStates (bool, optional): Whether or not to calculate from</span>
<span class="sd">                states directly. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The nucleation times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fromStates</span><span class="p">:</span>
            <span class="n">I_nucleation</span><span class="p">,</span> <span class="n">lateBloomers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmaCrossingIndices</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># nucleation times for all nucleated vials</span>
            <span class="c1"># need to make sure this is float so no problems arise later</span>
            <span class="n">t_nucleation_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[</span><span class="n">I_nucleation</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># non-nucleated vials are set to NaN</span>
            <span class="n">t_nucleation_states</span><span class="p">[</span><span class="n">lateBloomers</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">t_nucleation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">t_nucleation</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_nucleation_states</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_nucleation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_nucleation&quot;</span><span class="p">]</span>

        <span class="n">I_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVialGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t_nucleation</span><span class="p">[</span><span class="n">I_groups</span><span class="p">]</span></div>

<div class="viewcode-block" id="Snowflake.nucleationTemperatures"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.nucleationTemperatures">[docs]</a>    <span class="k">def</span> <span class="nf">nucleationTemperatures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">fromStates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return array of nucleation temperatures.</span>

<span class="sd">        Args:</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>
<span class="sd">            fromStates (bool, optional): Whether or not to calculate from</span>
<span class="sd">                states directly. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The nucleation temperatures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fromStates</span><span class="p">:</span>
            <span class="n">I_nucleation</span><span class="p">,</span> <span class="n">lateBloomers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmaCrossingIndices</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">T_nucleation_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">I</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">I</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">),</span> <span class="n">I_nucleation</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="nb">float</span>
            <span class="p">)</span>  <span class="c1"># should always be float, but just to be sure</span>

            <span class="c1"># non-nucleated vials are set to NaN</span>
            <span class="n">T_nucleation_states</span><span class="p">[</span><span class="n">lateBloomers</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">T_nucleation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">T_nucleation</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_nucleation_states</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">T_nucleation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;T_nucleation&quot;</span><span class="p">]</span>

        <span class="n">I_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVialGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">T_nucleation</span><span class="p">[</span><span class="n">I_groups</span><span class="p">]</span></div>

<div class="viewcode-block" id="Snowflake.solidificationTimes"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.solidificationTimes">[docs]</a>    <span class="k">def</span> <span class="nf">solidificationTimes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fromStates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return array of solidification times.</span>

<span class="sd">        Args:</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>
<span class="sd">            threshold (Optional[float], optional): The threshold used to</span>
<span class="sd">                define &#39;solidified&#39;. Defaults to self.solidificationThreshold.</span>
<span class="sd">            fromStates (bool, optional): Whether or not to calculate from</span>
<span class="sd">                states directly. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The solidification times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span>

        <span class="k">if</span> <span class="n">fromStates</span><span class="p">:</span>
            <span class="n">t_nucleation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nucleationTimes</span><span class="p">(</span><span class="n">fromStates</span><span class="o">=</span><span class="n">fromStates</span><span class="p">)</span>

            <span class="n">I_solidification</span><span class="p">,</span> <span class="n">neverGrownUp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmaCrossingIndices</span><span class="p">(</span>
                <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span>
            <span class="p">)</span>

            <span class="c1"># nucleation times for all nucleated vials</span>
            <span class="c1"># need to make sure this is float so no problems arise later</span>
            <span class="n">t_solidified</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[</span><span class="n">I_solidification</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># never fully solidified vials are set to NaN</span>
            <span class="n">t_solidified</span><span class="p">[</span><span class="n">neverGrownUp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># solidification is the difference between solidified and nucleated times</span>
            <span class="n">t_solidification_states</span> <span class="o">=</span> <span class="n">t_solidified</span>

            <span class="n">t_solidification</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">t_solidification</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_solidification_states</span>

            <span class="n">t_solidification</span> <span class="o">=</span> <span class="n">t_solidification</span> <span class="o">-</span> <span class="n">t_nucleation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">threshold</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Threshold cannot differ from solidificationThreshold when &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;not calculating from states.&quot;</span>
                <span class="p">)</span>
            <span class="n">t_solidification</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_solidification&quot;</span><span class="p">]</span>

        <span class="n">I_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVialGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t_solidification</span><span class="p">[</span><span class="n">I_groups</span><span class="p">]</span></div>

<div class="viewcode-block" id="Snowflake.sigmaCounter"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.sigmaCounter">[docs]</a>    <span class="k">def</span> <span class="nf">sigmaCounter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fromStates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return counter of vials satisfying sigma&gt;threshold at time.</span>

<span class="sd">        Args:</span>
<span class="sd">            time (Union[Sequence[float], float]): The time(s) for which to</span>
<span class="sd">                return the counter.</span>
<span class="sd">            threshold (Optional[float], optional): The threshold to apply.</span>
<span class="sd">                Defaults to self.solidificationThreshold.</span>
<span class="sd">            fromStates (bool, optional): Whether or not to calculate from</span>
<span class="sd">                states directly. Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Simulation needs to be run first.</span>
<span class="sd">            ValueError: fromStates is False and threshold is</span>
<span class="sd">                neither 0 or self.solidificationThreshold.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulationStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Simulation needs to be run first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default is to give solidified vials</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="c1"># we iterate over this,</span>
            <span class="c1"># so it must be a list</span>
            <span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span><span class="p">]</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">fromStates</span><span class="p">:</span>
                <span class="n">I_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_sigma</span><span class="p">[:,</span> <span class="n">I_time</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">threshold</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Threshold cannot differ from solidificationThreshold when &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;not calculating from states.&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_solidification&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">threshold</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_nucleation&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">counter</span></div>

<div class="viewcode-block" id="Snowflake.getVialGroup"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.getVialGroup">[docs]</a>    <span class="k">def</span> <span class="nf">getVialGroup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>  <span class="c1"># @ DRO: Need to adjust definitions for corner, edge, side etc...</span>
        <span class="sd">&quot;&quot;&quot;Return mask for given group.</span>

<span class="sd">        mask[i] = True iff vial[i] is in G where G can be a list of groups.</span>

<span class="sd">        Args:</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Can be &quot;corner&quot;, &quot;edge&quot;, &quot;side&quot;, &quot;core&quot;, &quot;all&quot;. Defaults to &quot;all&quot;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Group is not known.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A boolean mask of size (N_vials_tot,).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; S = Snowflake(N_vials = (2, 2, 1))</span>
<span class="sd">            &gt;&gt;&gt; S.getVialGroup(&#39;corner&#39;)</span>
<span class="sd">            array([True, True, True, True])</span>

<span class="sd">            &gt;&gt;&gt; S.getVialGroup([&#39;edge&#39;, &#39;core&#39;])</span>
<span class="sd">            array([False, False, False, False])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span><span class="p">]</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">VIAL_EXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buildInteractionMatrices</span><span class="p">()</span>

        <span class="n">myMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;corner&quot;</span><span class="p">:</span>
                <span class="c1"># for the 3D case, a corner vial has 3 external IAs</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">myMask</span> <span class="o">|</span> <span class="p">(</span><span class="n">VIAL_EXT</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">myMask</span> <span class="o">|</span> <span class="p">(</span><span class="n">VIAL_EXT</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;side&quot;</span><span class="p">:</span>
                <span class="c1"># side and edge are equivalent for 2D</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">myMask</span> <span class="o">|</span> <span class="p">(</span><span class="n">VIAL_EXT</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;core&quot;</span><span class="p">:</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">myMask</span> <span class="o">|</span> <span class="p">(</span><span class="n">VIAL_EXT</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">myMask</span> <span class="o">|</span> <span class="p">(</span><span class="n">VIAL_EXT</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;center&#39; is deprecated terminology. Please use &#39;core&#39; instead.&quot;</span><span class="p">,</span>
                    <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Group </span><span class="si">{</span><span class="n">g</span><span class="si">}</span><span class="s2"> is not a known vial group.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">myMask</span></div>

<div class="viewcode-block" id="Snowflake.plot"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;box&quot;</span><span class="p">,</span>
        <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;t_nucleation&quot;</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">context</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create plots for Snowflake object.</span>

<span class="sd">        Args:</span>
<span class="sd">            kind (str, optional): Type of plot to print. If input is</span>
<span class="sd">                &#39;trajectories&#39; will print temperature or sigma profile.</span>
<span class="sd">                Otherwise will print from stats dict. In that case,</span>
<span class="sd">                any sns.catplot &#39;kind&#39; input is allowed.</span>
<span class="sd">                Defaults to &quot;box&quot;.</span>
<span class="sd">            what (str, optional): What to plot. For trajectories valid inputs are</span>
<span class="sd">                sigma or temperature. Otherwise, it&#39;s the keys of the stats dict.</span>
<span class="sd">                I.e., t_nucleation, T_nucleation, t_solidification.</span>
<span class="sd">                Defaults to &quot;temperature&quot;.</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>
<span class="sd">            context (bool, optional): Whether or not to print additional context</span>
<span class="sd">                in the figure. Mainly used to add shelf temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stats_df</span><span class="p">,</span> <span class="n">traj_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;traj&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emptyStore</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No trajectories have been stored. Cannot plot.&quot;</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">traj_df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">stats_df</span>

        <span class="k">if</span> <span class="n">group</span> <span class="o">!=</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span><span class="p">]</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">group</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;traj&quot;</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">what</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No data for </span><span class="si">{</span><span class="n">what</span><span class="si">}</span><span class="s2"> for plot type </span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2"> and group </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Please check your inputs.&quot;</span>
                <span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;temperature&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">context</span><span class="p">:</span>
                <span class="n">N_timeSteps</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">t_tot</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>  <span class="c1"># the total number of timesteps</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_timeSteps</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">T_shelf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">tempProfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">T_shelf</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Shelf Temperature&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">what</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No data for </span><span class="si">{</span><span class="n">what</span><span class="si">}</span><span class="s2"> for plot type </span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2"> and group </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Please check your inputs.&quot;</span>
                <span class="p">)</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">catplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_sigmaCrossingIndices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return indices where sigma crosses threshold.</span>

<span class="sd">        A helper function identifying the time (indices) in the state matrix</span>
<span class="sd">        where sigma crosses a certain value.</span>
<span class="sd">        Args:</span>
<span class="sd">            threshold (Optional[float], optional): The threshold to apply.</span>
<span class="sd">                Defaults to self.solidificationThreshold.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Simulation needs to be run first.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, np.ndarray]: Indices where threshold is reached and</span>
<span class="sd">                mask identifying vials that never reach threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulationStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Simulation needs to be run first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span>

        <span class="n">Indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_sigma</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># vials that never exceeded solidification threshold</span>
        <span class="n">neverReached</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_sigma</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Indices</span><span class="p">,</span> <span class="n">neverReached</span>

    <span class="k">def</span> <span class="nf">_buildInteractionMatrices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">csr_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Build interaction matrices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[csr_matrix, np.ndarray]: Internal interaction matrix and external</span>
<span class="sd">                interaction vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is a (n_x*n_y*n_z) x (n_x*n_y*n_z) matrix</span>
        <span class="c1"># of interactions between vial pairs</span>
        <span class="c1"># Please note that, on any given shelf, we index vials this way:</span>
        <span class="c1"># [[1, 2, 3, 4, ..., n_x],</span>
        <span class="c1"># [n_x+1, n_x+2, ..., 2*n_x],</span>
        <span class="c1"># [...],</span>
        <span class="c1"># [(n_y-1)*n_x+1, ... , n_y*n_x]]</span>
        <span class="c1"># If one thinks of a shelf as an array, we hence use &#39;row-major&#39; ordering.</span>
        <span class="c1"># This is the same as numpy (most of the time), but different from Matlab.</span>
        <span class="c1"># These matrices can then be used as a sort of mask to overlay on, e.g.,</span>
        <span class="c1"># temperatures to calculate the correct driving forces for each vial/pair.</span>

        <span class="n">n_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># the number of vials in the horizontal direction</span>
        <span class="n">n_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># the number of vials in the vertical direction</span>
        <span class="n">n_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># the number of vials in the upwards/downwards direction</span>
        <span class="c1"># (perpendicular to the plane spanned by x and y)</span>

        <span class="c1"># create interaction matrix for horizontal (x-direction) interactions</span>
        <span class="c1"># matrix is 1 where two vials have a horizontal interaction and 0 otherwise</span>
        <span class="c1"># pairs (1,2), (2,3), ..., (i,i+1) have horizontal interactions,</span>
        <span class="c1"># except where i = n_x!</span>
        <span class="c1"># this means that in the IA matrix off-diagonal elements are 1</span>
        <span class="c1"># except where i%n_x==0 or j%n_x==0</span>
        <span class="n">dx_pattern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span> <span class="o">*</span> <span class="n">n_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,))</span>
        <span class="c1"># the vial at index position i+1 is at the edge -&gt; one neighbor less</span>
        <span class="n">idx_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span> <span class="o">*</span> <span class="n">n_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dx_pattern</span><span class="p">[</span><span class="n">idx_delete</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># we store this as a compressed sparse row (most efficient format?)</span>
        <span class="n">DX</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># create interaction matrix for vertical (y-direction) interactions</span>
        <span class="c1"># matrix is 1 where two vials have a horizontal interaction and 0 otherwise</span>
        <span class="c1"># pairs (1,n_x+1), (2,n_x+2), ..., (i,n_x+i) have vertical interactions</span>
        <span class="c1"># for i in [1, n_x*(n_y-1)]</span>
        <span class="c1"># this means that in the IA matrix n_x-removed-off-diagonal elements are 1</span>
        <span class="n">dy_pattern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_x</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_y</span> <span class="o">*</span> <span class="n">n_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),))</span>
        <span class="n">idy_delete</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_x</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_y</span> <span class="o">*</span> <span class="n">n_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_x</span><span class="p">):</span>  <span class="c1"># need to extract n_x points (i.e. an entire row)</span>
            <span class="c1"># every time we have an interaction</span>
            <span class="n">delete_n_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idy_delete</span><span class="p">]</span>  <span class="c1"># remove all interactions</span>
            <span class="n">dy_pattern</span><span class="p">[</span><span class="n">delete_n_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">DY</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dy_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">n_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dy_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="n">n_x</span><span class="p">))</span>

        <span class="c1"># create interaction matrix for upwards/downwards direction interactions</span>
        <span class="c1"># matrix is 1 where two vials have an interaction and 0 otherwise</span>
        <span class="c1"># pairs (1,(n_x*n_y)+1), (2,(n_x+n_y)+2), ..., (i,i+(n_x+n_y)) have interactions</span>
        <span class="c1"># for i in [1, n_x*n_y*(n_z-1)]</span>
        <span class="k">if</span> <span class="n">n_z</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dz_pattern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                <span class="p">(</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),)</span>
            <span class="p">)</span>  <span class="c1"># @DRO: For n_z = 1, there will be no pattern</span>
            <span class="n">DZ</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dz_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dz_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no pattern in z-direction</span>
            <span class="n">DZ</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># how many interactions does each vial</span>
        <span class="c1"># have with other vials</span>
        <span class="c1"># diagflat because sum over a sparse matrix</span>
        <span class="c1"># returns a np.matrix object, not an ndarray</span>
        <span class="n">VIAL_INT</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">DX</span> <span class="o">+</span> <span class="n">DY</span> <span class="o">+</span> <span class="n">DZ</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># the overall interaction matrix is given by the sum</span>
        <span class="c1"># of the interaction matrices DX and DY</span>
        <span class="c1"># minus the diagonal containing the sum of all vial-vial interactions</span>
        <span class="n">interactionMatrix</span> <span class="o">=</span> <span class="n">DX</span> <span class="o">+</span> <span class="n">DY</span> <span class="o">+</span> <span class="n">DZ</span> <span class="o">-</span> <span class="n">VIAL_INT</span>

        <span class="c1"># at most, any cubic vial on a 2D shelf can have</span>
        <span class="c1"># 4 interactions. 4 - VIAL_INT is the</span>
        <span class="c1"># number of external interactions (excl. the shelf).</span>
        <span class="c1"># For the 3D case this max is 6.</span>

        <span class="n">maxInteractions</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_z</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="n">VIAL_EXT</span> <span class="o">=</span> <span class="n">maxInteractions</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span> <span class="o">*</span> <span class="n">n_z</span><span class="p">,))</span> <span class="o">-</span> <span class="n">VIAL_INT</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">interactionMatrix</span><span class="p">,</span> <span class="n">VIAL_EXT</span>

    <span class="k">def</span> <span class="nf">_buildShelfHeatFlow</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build the shelf heat flow array.</span>

<span class="sd">        Because the shelf heat flow may be dependent on the rng if</span>
<span class="sd">        s_sigma_rel &gt; 0 we need to separate this process out so we</span>
<span class="sd">        can reinitialize this particular array for Snowfall.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store which seed was used to compute this</span>
        <span class="c1"># (getter method will know to recall this function</span>
        <span class="c1"># if the value changes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seedUsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 2D/shelf simulation</span>
            <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;s_sigma_rel&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s_sigma_rel&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">)</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s_sigma_rel&quot;</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 3D/pallet simulation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># k cannot be smaller than 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There were shelf heat transfer coefficients &lt; 0. I set them to 0.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_H_shelf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>  <span class="c1"># either a scalar or a vector</span>

    <span class="k">def</span> <span class="nf">_buildHeatflowMatrices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build heatflow matrices.&quot;&quot;&quot;</span>
        <span class="c1"># store which N_vials was used to compute this</span>
        <span class="c1"># (getter method will know to recall this function</span>
        <span class="c1"># if the value changes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>

        <span class="n">interactionMatrix</span><span class="p">,</span> <span class="n">VIAL_EXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buildInteractionMatrices</span><span class="p">()</span>

        <span class="c1"># compute H_int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_int</span> <span class="o">=</span> <span class="n">interactionMatrix</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;int&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span>

        <span class="c1"># compute H_ext</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_ext</span> <span class="o">=</span> <span class="n">VIAL_EXT</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;ext&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span>

        <span class="c1"># compute H_shelf (potentially depends on rng/seed)</span>
        <span class="c1"># will be zero in case of 3D system (assumes pallet in storage freezing)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buildShelfHeatFlow</span><span class="p">()</span>

<div class="viewcode-block" id="Snowflake.to_frame"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.to_frame">[docs]</a>    <span class="k">def</span> <span class="nf">to_frame</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n_timeSteps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">250</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Save statistics (and states) as pandas dataframe.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_timeSteps (int, optional): For states a reduced representation is stored.</span>
<span class="sd">                This defines the number of subsamples. Defaults to 250.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Simulation needs to run first.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[pd.DataFrame, Optional[pd.DataFrame]]: The statistics and if available</span>
<span class="sd">                the states over time (both in long form).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulationStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Simulation needs to be run first.&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;vial&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">VIAL_EXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buildInteractionMatrices</span><span class="p">()</span>

        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">VIAL_EXT</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;corner&quot;</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;edge&quot;</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;side&quot;</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;core&quot;</span>

        <span class="n">stats_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;vial&quot;</span><span class="p">])</span>

        <span class="n">n_storedStates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_storedStates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># to reduce computational cost we limit number of timepoints to n_timeSteps</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="p">[:,</span> <span class="p">::</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_timeSteps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))])</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[::</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_timeSteps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))]</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Time&quot;</span>

            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s2">&quot;temperature&quot;</span><span class="p">,</span> <span class="n">n_storedStates</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="n">n_storedStates</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;vial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">VIAL_EXT</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;corner&quot;</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;edge&quot;</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;side&quot;</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;core&quot;</span>

            <span class="n">traj_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;vial&quot;</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">traj_df</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">stats_df</span><span class="p">,</span> <span class="n">traj_df</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return string representation of the Snowflake class.</span>

<span class="sd">        A simple indicator of the most important properties of the Snowflake.</span>
<span class="sd">        Returns:</span>
<span class="sd">            str: The Snowflake class string representation giving some basic info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Snowflake([N_vials: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;dt: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="si">}</span><span class="s2">, seed: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="si">}</span><span class="s2">])&quot;</span>
        <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021-2024, Leif-Thore Deck, Andraž Košir, David Ochsenbein.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> and ❤️  using a custom <a href="https://github.com/LinxiFan/Stanford-theme">theme</a> based on <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.1.0.post1.dev34+ga1dec07.d20230707',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>