
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ethz_snow.snowflake &#8212; ethz_snow 0.0.0 documentation</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">ethz_snow 0.0.0 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../readme.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../tutorial.html">
   Tutorial
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../license.html">
   License
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../authors.html">
   Authors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../changelog.html">
   Changelog
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../api/modules.html">
   Module Reference
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../api/ethz_snow.html">
     ethz_snow package
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <h1>Source code for ethz_snow.snowflake</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implement Snowflake class.</span>

<span class="sd">This module contains the Snowflake class used to run simulations</span>
<span class="sd">of water nucleation in vials.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">ethz_snow.operatingConditions</span> <span class="kn">import</span> <span class="n">OperatingConditions</span>
<span class="kn">from</span> <span class="nn">ethz_snow.constants</span> <span class="kn">import</span> <span class="n">calculateDerived</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="c1"># import matplotlib.pyplot as plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span>

<span class="n">HEATFLOW_REQUIREDKEYS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;ext&quot;</span><span class="p">,</span> <span class="s2">&quot;s0&quot;</span><span class="p">)</span>
<span class="n">VIAL_GROUPS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;corner&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Snowflake"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake">[docs]</a><span class="k">class</span> <span class="nc">Snowflake</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class to handle a single Stochastic Nucleation of Water simulation.</span>

<span class="sd">    More information regarding the equations and their derivation can be found in</span>
<span class="sd">    XXX, Deck et al. (2021).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        configPath (Optional[str]): The path of the (optional) custom config yaml.</span>
<span class="sd">        const (dict): A dictionary of constants to be used.</span>
<span class="sd">        dt (float): Time step.</span>
<span class="sd">        H_ext (np.ndarray): External heat transfer vector.</span>
<span class="sd">        H_int (csr_matrix): Internal heat transfer matrix.</span>
<span class="sd">        H_shelf (np.ndarray): Shelf heat transfer vector.</span>
<span class="sd">        k (dict): Heat transfer coefficients.</span>
<span class="sd">        N_vials (tuple): Number of vials in each dimension.</span>
<span class="sd">        N_vials_total (int): Total number of vials.</span>
<span class="sd">        opcond (OperatingConditions): Operating conditions of run.</span>
<span class="sd">        seed (int): Seed to be used in rng.</span>
<span class="sd">        simulationStatus (int): Status of simulation (0 = not run, 1 = run).</span>
<span class="sd">        solidificationThreshold (float): What sigma value constitutes a &#39;solid&#39;.</span>
<span class="sd">        stats (dict): Run statistics (nucleation time, etc.).</span>
<span class="sd">        X_sigma (np.ndarray): Sigma state over time.</span>
<span class="sd">        X_T (np.ndarray): Temperature state over time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;ext&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;s0&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;s_sigma_rel&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">},</span>
        <span class="n">N_vials</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">7</span><span class="p">,</span>
            <span class="mi">7</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">),</span>  <span class="c1"># should this be part of operating conditions?</span>
        <span class="n">storeStates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">solidificationThreshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2021</span><span class="p">,</span>
        <span class="n">opcond</span><span class="p">:</span> <span class="n">OperatingConditions</span> <span class="o">=</span> <span class="n">OperatingConditions</span><span class="p">(),</span>
        <span class="n">configPath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a Snowflake object.</span>

<span class="sd">        Args:</span>
<span class="sd">            k (dict, optional): A dictionary containing the heat transfer coefficients.</span>
<span class="sd">                Must contain keys &#39;int&#39;, &#39;ext&#39;, &#39;s0&#39;.</span>
<span class="sd">                Defaults to {&quot;int&quot;: 20, &quot;ext&quot;: 20, &quot;s0&quot;: 20, &quot;s_sigma_rel&quot;: 0.1}.</span>
<span class="sd">            N_vials (Tuple[int, int, int], optional): Number of vials in each dimension.</span>
<span class="sd">                Defaults to ( 7, 7, 1).</span>
<span class="sd">            storeStates (Union[str, Sequence[str], Sequence[int], None]):</span>
<span class="sd">                Whether and for which vials to store states (temp, sigma).</span>
<span class="sd">            solidificationThreshold (float, optional): What sigma value is</span>
<span class="sd">                a &#39;solid&#39;. Defaults to 0.9.</span>
<span class="sd">            dt (float, optional): Time step size. Defaults to 2.</span>
<span class="sd">            seed (int, optional): Seed to use for rng. Defaults to 2021.</span>
<span class="sd">            opcond (OperatingConditions, optional): Operating conditions to apply.</span>
<span class="sd">                Defaults to OperatingConditions().</span>
<span class="sd">            configPath (Optional[str], optional): The location of a custom configuration</span>
<span class="sd">                file (in yaml format), used to update/overwrite the default settings.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If k is not a dict.</span>
<span class="sd">            ValueError: If k does not contain all necessary keys.</span>
<span class="sd">            NotImplementedError: If N_vials[2] is not 1. Only 2D model is implemented.</span>
<span class="sd">            TypeError: If opcond is not of type operatingConditions.</span>
<span class="sd">            ValueError: If storeStates is not meaningful.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; Sf = Snowflake()</span>
<span class="sd">            &gt;&gt;&gt; Sf = Snowflake(Nvials=(4, 3, 1), dt = 5)</span>
<span class="sd">            &gt;&gt;&gt; Sf = Snowflake(storeStates = [&#39;edge_random_4&#39;, &#39;uniform.center.5&#39;])</span>
<span class="sd">            &gt;&gt;&gt; Sf = Snowflake(storeStates = (0, 4, 10))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input k must be of type dict. Was given </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">key</span> <span class="ow">in</span> <span class="n">k</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">HEATFLOW_REQUIREDKEYS</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;A required key was missing from dictionary k, specifically &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">HEATFLOW_REQUIREDKEYS</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N_vials</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># we exepct this to be immutable</span>
            <span class="n">N_vials</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">N_vials</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Only 2D (shelf) models are implemented at this moment.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span> <span class="o">=</span> <span class="n">N_vials</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opcond</span><span class="p">,</span> <span class="n">OperatingConditions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Input opcond must be an instance of class OperatingConditions.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span> <span class="o">=</span> <span class="n">opcond</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span> <span class="o">=</span> <span class="n">solidificationThreshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_simulationStatus</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_H_int</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_ext</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_shelf</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">configPath</span> <span class="o">=</span> <span class="n">configPath</span>

        <span class="c1"># store the seed to look it up if need be</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>

        <span class="c1"># remember what N_vials was used to build heat flow matrices</span>
        <span class="c1"># so if it changes we know to rebuild them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_emptyStore</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">storeStates</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">storeStates</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">storeStates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">storeStates</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Entries in storeStates must be &gt;0 &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;and &lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">storageMask</span><span class="p">[</span><span class="n">storeStates</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">storeStates</span><span class="p">]):</span>
                <span class="n">storageMasks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpretStorageString</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">storeStates</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">storageMasks</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;storeStates must be a sequence of all int or all str.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">storeStates</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">storageMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpretStorageString</span><span class="p">(</span><span class="n">storeStates</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">storeStates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_emptyStore</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span> <span class="o">=</span> <span class="n">storageMask</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">simulationStatus</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return simulation status of instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Simulation status. 0 = not run, 1 = run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_simulationStatus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_simulationStatus</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulationStatus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_int</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the internal heat transfer matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            csr_matrix: The internal heat transfer matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_int</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buildHeatflowMatrices</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_H_int</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the external heat transfer vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The external heat transfer vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_ext</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buildHeatflowMatrices</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_H_ext</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_shelf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the shelf heat transfer vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The shelf heat transfer vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_shelf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seedUsed</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buildShelfHeatFlow</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_H_shelf</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">N_vials_total</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return total number of vials in system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X_T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the temperature states.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array containing the vial temperatures over time.</span>
<span class="sd">                This is just a slice of _X!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">)),</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the sigma states.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array containing the vial sigmas over time.</span>
<span class="sd">                This is just a slice of _X!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">))</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">seed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get or set the random seed.</span>

<span class="sd">        Setting the seed value will initialize a new rng under the hood.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The seed of the Snowflake.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span>

    <span class="nd">@seed</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># best practice is now to store the rng in an object and pass it around</span>
        <span class="c1"># https://towardsdatascience.com/stop-using-numpy-random-seed-581a9972805f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># store the seed to look it up if need be</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># let H_shelf figure out whether it needs to be updated</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_shelf</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">configPath</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get configPath property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_configPath</span>

    <span class="nd">@configPath</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">configPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set configPath property.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">=</span> <span class="n">calculateDerived</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_configPath</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_interpretStorageString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">myString</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpret the storeState string.</span>

<span class="sd">        Returns the interpretation of the storeState string</span>
<span class="sd">        indicating which states should be stored in _X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">myString</span> <span class="o">=</span> <span class="n">myString</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span><span class="n">word</span> <span class="ow">in</span> <span class="n">myString</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">VIAL_GROUPS</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="s2">&quot;uniform&quot;</span><span class="p">]]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid vial group or key word used in storeStates.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">word</span> <span class="ow">in</span> <span class="n">myString</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">VIAL_GROUPS</span><span class="p">)]):</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">VIAL_GROUPS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">:</span>
                    <span class="n">storageMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVialGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">elif</span> <span class="p">(</span><span class="s2">&quot;random&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;uniform&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">):</span>
            <span class="c1"># assume vial group &#39;all&#39; is implied</span>
            <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;random&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;uniform&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">):</span>
            <span class="n">howMany</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="n">myString</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">howMany</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># unclear how many to pick, default is 10%</span>
                <span class="n">howMany</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">howMany</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">howMany</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">howMany</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">howMany</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;storeStates strings must contain one number at most.&quot;</span><span class="p">)</span>

            <span class="n">I_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">storageMask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;random&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">:</span>
                <span class="n">I_toStore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">I_candidates</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">howMany</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;uniform&quot;</span> <span class="ow">in</span> <span class="n">myString</span><span class="p">:</span>
                <span class="n">stepSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I_candidates</span><span class="p">)</span> <span class="o">/</span> <span class="n">howMany</span><span class="p">))</span>
                <span class="n">I_fromCandidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">I_candidates</span><span class="p">),</span> <span class="n">stepSize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">I_toStore</span> <span class="o">=</span> <span class="n">I_candidates</span><span class="p">[</span><span class="n">I_fromCandidates</span><span class="p">]</span>
            <span class="n">storageMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">storageMask</span><span class="p">[</span><span class="n">I_toStore</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">storageMask</span>

<div class="viewcode-block" id="Snowflake.run"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the simulation.&quot;&quot;&quot;</span>
        <span class="c1"># clean up any potential old simulations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Obtain external temperature profile over time</span>
        <span class="n">T_shelf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">tempProfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">T_ext</span> <span class="o">=</span> <span class="n">T_shelf</span>  <span class="c1"># need to make a switch so that this can be decoupled - DRO XX</span>

        <span class="c1"># store stuff in local variables to reduce getter method calls</span>
        <span class="c1"># note that getter method handles the construction of the matrices</span>
        <span class="c1"># in case they haven&#39;t been initialized yet</span>
        <span class="n">H_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_int</span>
        <span class="n">H_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_ext</span>
        <span class="n">H_shelf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_shelf</span>

        <span class="c1"># constants</span>
        <span class="n">solid_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;solid_fraction&quot;</span><span class="p">]</span>
        <span class="n">cp_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;cp_s&quot;</span><span class="p">]</span>
        <span class="n">cp_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;cp_w&quot;</span><span class="p">]</span>
        <span class="n">cp_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;cp_i&quot;</span><span class="p">]</span>
        <span class="n">cp_solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;cp_solution&quot;</span><span class="p">]</span>
        <span class="n">depression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;depression&quot;</span><span class="p">]</span>
        <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span>
        <span class="n">beta_solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;beta_solution&quot;</span><span class="p">]</span>
        <span class="n">T_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;T_eq&quot;</span><span class="p">]</span>
        <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;hl&quot;</span><span class="p">]</span>
        <span class="n">kb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;kb&quot;</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;V&quot;</span><span class="p">]</span>

        <span class="n">N_timeSteps</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">t_tot</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># the total number of timesteps</span>
        <span class="n">N_vials_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span>

        <span class="c1"># Initial state of the system</span>
        <span class="c1"># initial temperature</span>
        <span class="n">T_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">cooling</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>  <span class="c1"># [C]</span>
        <span class="c1"># state of the vials</span>
        <span class="n">sigma_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">)</span>  <span class="c1"># (0 = liq, 1 = completely frozen)</span>

        <span class="c1"># Pre-allocate memory</span>
        <span class="c1"># our state matrix containing the entire history of the system</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">),</span> <span class="n">N_timeSteps</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_timeSteps</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">t_nucleation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
            <span class="n">T_nucleation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
            <span class="n">t_solidification</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">k_CN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">cnt</span><span class="p">)</span>

        <span class="c1"># Iterate over time steps</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_timeSteps</span><span class="p">):</span>

            <span class="n">T_shelf_k</span> <span class="o">=</span> <span class="n">T_shelf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">T_ext_k</span> <span class="o">=</span> <span class="n">T_ext</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="c1"># toc1_l = time.perf_counter()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emptyStore</span><span class="p">:</span>
                <span class="c1"># does not give a huge boost.</span>
                <span class="n">x_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">T_k</span><span class="p">,</span> <span class="n">sigma_k</span><span class="p">])</span>
                <span class="n">X</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">])]</span>

            <span class="c1"># calculate heatflows for all vials</span>
            <span class="n">q_k</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">H_int</span> <span class="o">@</span> <span class="n">T_k</span> <span class="o">+</span> <span class="n">H_ext</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_ext_k</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">)</span> <span class="o">+</span> <span class="n">H_shelf</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_shelf_k</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># [XXX] units? - DRO</span>

            <span class="c1"># a mask that is True where a vial is still fully liquid</span>
            <span class="n">liquidMask</span> <span class="o">=</span> <span class="n">sigma_k</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">solidMask</span> <span class="o">=</span> <span class="o">~</span><span class="n">liquidMask</span>  <span class="c1"># for convenience</span>
            <span class="c1"># SOLID(IFYING) VIALS</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">solidMask</span><span class="p">):</span>
                <span class="n">solidifiedMask</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_k</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span>
                    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_solidification&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_solidification&quot;</span><span class="p">][</span><span class="n">solidifiedMask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_nucleation&quot;</span><span class="p">][</span><span class="n">solidifiedMask</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># heat capacity of solidifying vials</span>
                <span class="c1"># a vector of cps for all solidifying vials</span>
                <span class="n">cp_sigma</span> <span class="o">=</span> <span class="n">solid_fraction</span> <span class="o">*</span> <span class="n">cp_s</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">solid_fraction</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">cp_i</span> <span class="o">-</span> <span class="n">cp_w</span><span class="p">)</span> <span class="o">+</span> <span class="n">cp_w</span>
                <span class="p">)</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">depression</span> <span class="o">*</span> <span class="n">mass</span> <span class="o">*</span> <span class="n">cp_sigma</span>

                <span class="n">deltaSigma</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">q_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span>
                    <span class="o">/</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                <span class="p">)</span>
                <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span> <span class="o">+</span> <span class="n">deltaSigma</span>
                <span class="c1"># assumption is that during solidification T = Teq</span>
                <span class="n">T_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_eq</span> <span class="o">-</span> <span class="n">depression</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigma_k</span><span class="p">[</span><span class="n">solidMask</span><span class="p">]))</span>

            <span class="c1"># LIQUID VIALS</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">liquidMask</span><span class="p">):</span>
                <span class="c1"># DRO: Leif, I&#39;ve moved the dt out of the Hs</span>
                <span class="c1"># because I associate Q with fluxes</span>
                <span class="n">T_k</span><span class="p">[</span><span class="n">liquidMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_k</span><span class="p">[</span><span class="n">liquidMask</span><span class="p">]</span> <span class="o">+</span> <span class="n">q_k</span><span class="p">[</span><span class="n">liquidMask</span><span class="p">]</span> <span class="o">/</span> <span class="n">hl</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                <span class="c1"># a mask that is True where the temperature is</span>
                <span class="c1"># below the equilibrium temperature</span>
                <span class="n">superCooledMask</span> <span class="o">=</span> <span class="n">T_k</span> <span class="o">&lt;</span> <span class="n">T_eq</span>
                <span class="c1"># a vial that is both liquid and supercooled can nucleate</span>
                <span class="n">nucleationCandidatesMask</span> <span class="o">=</span> <span class="n">liquidMask</span> <span class="o">&amp;</span> <span class="n">superCooledMask</span>
                <span class="c1"># the total number of nucleation candidates</span>
                <span class="n">n_nucleationCandidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nucleationCandidatesMask</span><span class="p">)</span>

                <span class="c1"># nucleation probabilities for candidates</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">)</span>
                <span class="n">diceRolls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_vials_total</span><span class="p">)</span>

                <span class="n">P</span><span class="p">[</span><span class="n">nucleationCandidatesMask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">kb</span> <span class="o">*</span> <span class="n">V</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_eq</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">[</span><span class="n">nucleationCandidatesMask</span><span class="p">])</span> <span class="o">**</span> <span class="n">b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                <span class="p">)</span>
                <span class="c1"># when we reach the timepoint of controlled nucleation</span>
                <span class="c1"># all vials (that thermodynamically can) nucleate</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">k_CN</span><span class="p">:</span>
                    <span class="n">P</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">frac_justCant</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nucleationCandidatesMask</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_vials_total</span>
                    <span class="k">if</span> <span class="n">frac_justCant</span> <span class="o">&gt;=</span> <span class="mf">0.1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;WARNING: A significant number of vials &quot;</span>
                                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">frac_justCant</span> <span class="o">*</span> <span class="mi">100</span><span class="si">:</span><span class="s2">4.1f</span><span class="si">}</span><span class="s2">%) &quot;</span>
                                <span class="o">+</span> <span class="s2">&quot;were not supercooled when controlled &quot;</span>
                                <span class="o">+</span> <span class="s2">&quot;nucleation triggered.&quot;</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">diceRolls</span><span class="p">[</span><span class="n">nucleationCandidatesMask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span>
                    <span class="n">n_nucleationCandidates</span>
                <span class="p">)</span>

                <span class="c1"># Nucleation</span>
                <span class="n">nucleatedVialsMask</span> <span class="o">=</span> <span class="n">nucleationCandidatesMask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">diceRolls</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">)</span>

                <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_nucleation&quot;</span><span class="p">][</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;T_nucleation&quot;</span><span class="p">][</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span>

                <span class="n">q0</span> <span class="o">=</span> <span class="p">(</span><span class="n">T_eq</span> <span class="o">-</span> <span class="n">T_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">])</span> <span class="o">*</span> <span class="n">cp_solution</span> <span class="o">*</span> <span class="n">mass</span>

                <span class="n">sigma_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">q0</span> <span class="o">/</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">beta_solution</span><span class="p">)</span>
                <span class="c1"># assumption is that during solidification T = Teq</span>
                <span class="n">T_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_eq</span> <span class="o">-</span> <span class="n">depression</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigma_k</span><span class="p">[</span><span class="n">nucleatedVialsMask</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">X</span>  <span class="c1"># store the state matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="n">t</span>  <span class="c1"># store the time vector</span></div>

<div class="viewcode-block" id="Snowflake.nucleationTimes"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.nucleationTimes">[docs]</a>    <span class="k">def</span> <span class="nf">nucleationTimes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">fromStates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return array of nucleation times.</span>

<span class="sd">        Args:</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>
<span class="sd">            fromStates (bool, optional): Whether or not to calculate from</span>
<span class="sd">                states directly. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The nucleation times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fromStates</span><span class="p">:</span>
            <span class="n">I_nucleation</span><span class="p">,</span> <span class="n">lateBloomers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmaCrossingIndices</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># nucleation times for all nucleated vials</span>
            <span class="c1"># need to make sure this is float so no problems arise later</span>
            <span class="n">t_nucleation_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[</span><span class="n">I_nucleation</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># non-nucleated vials are set to NaN</span>
            <span class="n">t_nucleation_states</span><span class="p">[</span><span class="n">lateBloomers</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">t_nucleation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">t_nucleation</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_nucleation_states</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_nucleation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_nucleation&quot;</span><span class="p">]</span>

        <span class="n">I_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVialGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t_nucleation</span><span class="p">[</span><span class="n">I_groups</span><span class="p">]</span></div>

<div class="viewcode-block" id="Snowflake.nucleationTemperatures"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.nucleationTemperatures">[docs]</a>    <span class="k">def</span> <span class="nf">nucleationTemperatures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">fromStates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return array of nucleation temperatures.</span>

<span class="sd">        Args:</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>
<span class="sd">            fromStates (bool, optional): Whether or not to calculate from</span>
<span class="sd">                states directly. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The nucleation temperatures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fromStates</span><span class="p">:</span>
            <span class="n">I_nucleation</span><span class="p">,</span> <span class="n">lateBloomers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmaCrossingIndices</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">T_nucleation_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">I</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">I</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">),</span> <span class="n">I_nucleation</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="nb">float</span>
            <span class="p">)</span>  <span class="c1"># should always be float, but just to be sure</span>

            <span class="c1"># non-nucleated vials are set to NaN</span>
            <span class="n">T_nucleation_states</span><span class="p">[</span><span class="n">lateBloomers</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">T_nucleation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">T_nucleation</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">T_nucleation_states</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">T_nucleation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;T_nucleation&quot;</span><span class="p">]</span>

        <span class="n">I_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVialGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">T_nucleation</span><span class="p">[</span><span class="n">I_groups</span><span class="p">]</span></div>

<div class="viewcode-block" id="Snowflake.solidificationTimes"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.solidificationTimes">[docs]</a>    <span class="k">def</span> <span class="nf">solidificationTimes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fromStates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return array of solidification times.</span>

<span class="sd">        Args:</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>
<span class="sd">            threshold (Optional[float], optional): The threshold used to</span>
<span class="sd">                define &#39;solidified&#39;. Defaults to self.solidificationThreshold.</span>
<span class="sd">            fromStates (bool, optional): Whether or not to calculate from</span>
<span class="sd">                states directly. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The solidification times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span>

        <span class="k">if</span> <span class="n">fromStates</span><span class="p">:</span>
            <span class="n">t_nucleation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nucleationTimes</span><span class="p">(</span><span class="n">fromStates</span><span class="o">=</span><span class="n">fromStates</span><span class="p">)</span>

            <span class="n">I_solidification</span><span class="p">,</span> <span class="n">neverGrownUp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigmaCrossingIndices</span><span class="p">(</span>
                <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span>
            <span class="p">)</span>

            <span class="c1"># nucleation times for all nucleated vials</span>
            <span class="c1"># need to make sure this is float so no problems arise later</span>
            <span class="n">t_solidified</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[</span><span class="n">I_solidification</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># never fully solidified vials are set to NaN</span>
            <span class="n">t_solidified</span><span class="p">[</span><span class="n">neverGrownUp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># solidification is the difference between solidified and nucleated times</span>
            <span class="n">t_solidification_states</span> <span class="o">=</span> <span class="n">t_solidified</span>

            <span class="n">t_solidification</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">t_solidification</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_solidification_states</span>

            <span class="n">t_solidification</span> <span class="o">=</span> <span class="n">t_solidification</span> <span class="o">-</span> <span class="n">t_nucleation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">threshold</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Threshold cannot differ from solidificationThreshold when &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;not calculating from states.&quot;</span>
                <span class="p">)</span>
            <span class="n">t_solidification</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_solidification&quot;</span><span class="p">]</span>

        <span class="n">I_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVialGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t_solidification</span><span class="p">[</span><span class="n">I_groups</span><span class="p">]</span></div>

<div class="viewcode-block" id="Snowflake.sigmaCounter"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.sigmaCounter">[docs]</a>    <span class="k">def</span> <span class="nf">sigmaCounter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fromStates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return counter of vials satisfying sigma&gt;threshold at time.</span>

<span class="sd">        Args:</span>
<span class="sd">            time (Union[Sequence[float], float]): The time(s) for which to</span>
<span class="sd">                return the counter.</span>
<span class="sd">            threshold (Optional[float], optional): The threshold to apply.</span>
<span class="sd">                Defaults to self.solidificationThreshold.</span>
<span class="sd">            fromStates (bool, optional): Whether or not to calculate from</span>
<span class="sd">                states directly. Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Simulation needs to be run first.</span>
<span class="sd">            ValueError: fromStates is False and threshold is</span>
<span class="sd">                neither 0 or self.solidificationThreshold.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulationStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Simulation needs to be run first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default is to give solidified vials</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="c1"># we iterate over this,</span>
            <span class="c1"># so it must be a list</span>
            <span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span><span class="p">]</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">fromStates</span><span class="p">:</span>
                <span class="n">I_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_sigma</span><span class="p">[:,</span> <span class="n">I_time</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">threshold</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Threshold cannot differ from solidificationThreshold when &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;not calculating from states.&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_solidification&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">threshold</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;t_nucleation&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">counter</span></div>

<div class="viewcode-block" id="Snowflake.getVialGroup"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.getVialGroup">[docs]</a>    <span class="k">def</span> <span class="nf">getVialGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return mask for given group.</span>

<span class="sd">        mask[i] = True iff vial[i] is in G where G can be a list of groups.</span>

<span class="sd">        Args:</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Group is not known.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A boolean mask of size (N_vials_tot,).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; S = Snowflake(N_vials = (2, 2, 1))</span>
<span class="sd">            &gt;&gt;&gt; S.getVialGroup(&#39;corner&#39;)</span>
<span class="sd">            array([True, True, True, True])</span>

<span class="sd">            &gt;&gt;&gt; S.getVialGroup([&#39;edge&#39;, &#39;center&#39;])</span>
<span class="sd">            array([False, False, False, False])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span><span class="p">]</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">VIAL_EXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buildInteractionMatrices</span><span class="p">()</span>

        <span class="n">myMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;corner&quot;</span><span class="p">:</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">myMask</span> <span class="o">|</span> <span class="p">(</span><span class="n">VIAL_EXT</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">myMask</span> <span class="o">|</span> <span class="p">(</span><span class="n">VIAL_EXT</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">myMask</span> <span class="o">|</span> <span class="p">(</span><span class="n">VIAL_EXT</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">myMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Group </span><span class="si">{</span><span class="n">g</span><span class="si">}</span><span class="s2"> is not a known vial group.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">myMask</span></div>

<div class="viewcode-block" id="Snowflake.plot"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;box&quot;</span><span class="p">,</span>
        <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;t_nucleation&quot;</span><span class="p">,</span>
        <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">context</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create plots for Snowflake object.</span>

<span class="sd">        Args:</span>
<span class="sd">            kind (str, optional): Type of plot to print. If input is</span>
<span class="sd">                &#39;trajectories&#39; will print temperature or sigma profile.</span>
<span class="sd">                Otherwise will print from stats dict. In that case,</span>
<span class="sd">                any sns.catplot &#39;kind&#39; input is allowed.</span>
<span class="sd">                Defaults to &quot;box&quot;.</span>
<span class="sd">            what (str, optional): What to plot. For trajectories valid inputs are</span>
<span class="sd">                sigma or temperature. Otherwise, it&#39;s the keys of the stats dict.</span>
<span class="sd">                I.e., t_nucleation, T_nucleation, t_solidification.</span>
<span class="sd">                Defaults to &quot;temperature&quot;.</span>
<span class="sd">            group (Union[str, Sequence[str]], optional): Subgroup to return.</span>
<span class="sd">                Defaults to &quot;all&quot;.</span>
<span class="sd">            context (bool, optional): Whether or not to print additional context</span>
<span class="sd">                in the figure. Mainly used to add shelf temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stats_df</span><span class="p">,</span> <span class="n">traj_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;traj&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emptyStore</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No trajectories have been stored. Cannot plot.&quot;</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">traj_df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">stats_df</span>

        <span class="k">if</span> <span class="n">group</span> <span class="o">!=</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span><span class="p">]</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">group</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;traj&quot;</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">what</span><span class="p">)]</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;temperature&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">context</span><span class="p">:</span>
                <span class="n">N_timeSteps</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">t_tot</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>  <span class="c1"># the total number of timesteps</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_timeSteps</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">T_shelf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opcond</span><span class="o">.</span><span class="n">tempProfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">T_shelf</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Shelf Temperature&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">what</span><span class="p">)]</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">catplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_sigmaCrossingIndices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return indices where sigma crosses threshold.</span>

<span class="sd">        A helper function identifying the time (indices) in the state matrix</span>
<span class="sd">        where sigma crosses a certain value.</span>
<span class="sd">        Args:</span>
<span class="sd">            threshold (Optional[float], optional): The threshold to apply.</span>
<span class="sd">                Defaults to self.solidificationThreshold.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Simulation needs to be run first.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, np.ndarray]: Indices where threshold is reached and</span>
<span class="sd">                mask identifying vials that never reach threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulationStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Simulation needs to be run first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solidificationThreshold</span>

        <span class="n">Indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_sigma</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># vials that never exceeded solidification threshold</span>
        <span class="n">neverReached</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_sigma</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Indices</span><span class="p">,</span> <span class="n">neverReached</span>

    <span class="k">def</span> <span class="nf">_buildInteractionMatrices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">csr_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Build interaction matrices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[csr_matrix, np.ndarray]: Internal interaction matrix and external</span>
<span class="sd">                interaction vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is a (n_x*n_y*n_z) x (n_x*n_y*n_z) matrix</span>
        <span class="c1"># of interactions between vial pairs</span>
        <span class="c1"># Please note that, on any given shelf, we index vials this way:</span>
        <span class="c1"># [[1, 2, 3, 4, ..., n_x],</span>
        <span class="c1"># [n_x+1, n_x+2, ..., 2*n_x],</span>
        <span class="c1"># [...],</span>
        <span class="c1"># [(n_y-1)*n_x+1, ... , n_y*n_x]]</span>
        <span class="c1"># If one thinks of a shelf as an array, we hence use &#39;row-major&#39; ordering.</span>
        <span class="c1"># This is the same as numpy (most of the time), but different from Matlab.</span>
        <span class="c1"># These matrices can then be used as a sort of mask to overlay on, e.g.,</span>
        <span class="c1"># temperatures to calculate the correct driving forces for each vial/pair.</span>

        <span class="n">n_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># the number of vials in the horizontal direction</span>
        <span class="n">n_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># the number of vials in the vertical direction</span>
        <span class="n">n_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># the number of vials in the upwards/downwards direction</span>
        <span class="c1"># (perpendicular to the plane spanned by x and y)</span>

        <span class="c1"># create interaction matrix for horizontal (x-direction) interactions</span>
        <span class="c1"># matrix is 1 where two vials have a horizontal interaction and 0 otherwise</span>
        <span class="c1"># pairs (1,2), (2,3), ..., (i,i+1) have horizontal interactions,</span>
        <span class="c1"># except where i = n_x!</span>
        <span class="c1"># this means that in the IA matrix off-diagonal elements are 1</span>
        <span class="c1"># except where i%n_x==0 or j%n_x==0</span>
        <span class="n">dx_pattern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,))</span>
        <span class="c1"># the vial at index position i+1 is at the edge -&gt; one neighbor less</span>
        <span class="n">idx_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dx_pattern</span><span class="p">[</span><span class="n">idx_delete</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># we store this as a compressed sparse row (most efficient format?)</span>
        <span class="n">DX</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dx_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># create interaction matrix for vertical (y-direction) interactions</span>
        <span class="c1"># matrix is 1 where two vials have a horizontal interaction and 0 otherwise</span>
        <span class="c1"># pairs (1,n_x+1), (2,n_x+2), ..., (i,n_x+i) have vertical interactions</span>
        <span class="c1"># for i in [1, n_x*(n_y-1)]</span>
        <span class="c1"># this means that in the IA matrix n_x-removed-off-diagonal elements are 1</span>
        <span class="n">dy_pattern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span> <span class="o">-</span> <span class="n">n_x</span><span class="p">,))</span>
        <span class="n">DY</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dy_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">n_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dy_pattern</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="n">n_x</span><span class="p">))</span>

        <span class="c1"># how many interactions does each vial</span>
        <span class="c1"># have with other vials</span>
        <span class="c1"># diagflat because sum over a sparse matrix</span>
        <span class="c1"># returns a np.matrix object, not an ndarray</span>
        <span class="n">VIAL_INT</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">DX</span> <span class="o">+</span> <span class="n">DY</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># the overall interaction matrix is given by the sum</span>
        <span class="c1"># of the interaction matrices DX and DY</span>
        <span class="c1"># minus the diagonal containing the sum of all vial-vial interactions</span>
        <span class="n">interactionMatrix</span> <span class="o">=</span> <span class="n">DX</span> <span class="o">+</span> <span class="n">DY</span> <span class="o">-</span> <span class="n">VIAL_INT</span>

        <span class="c1"># at most, any cubic vial on a 2D shelf can have</span>
        <span class="c1"># 4 interactions. 4 - VIAL_INT is the</span>
        <span class="c1"># number of external interactions (excl. the shelf)</span>
        <span class="c1"># is it worth storing this as a sparse matrix? - DRO XXX</span>
        <span class="n">VIAL_EXT</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">n_y</span><span class="p">,))</span> <span class="o">-</span> <span class="n">VIAL_INT</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">interactionMatrix</span><span class="p">,</span> <span class="n">VIAL_EXT</span>

    <span class="k">def</span> <span class="nf">_buildShelfHeatFlow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build the shelf heat flow array.</span>

<span class="sd">        Because the shelf heat flow may be dependent on the rng if</span>
<span class="sd">        s_sigma_rel &gt; 0 we need to separate this process out so we</span>
<span class="sd">        can reinitialize this particular array for Snowfall.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store which seed was used to compute this</span>
        <span class="c1"># (getter method will know to recall this function</span>
        <span class="c1"># if the value changes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seedUsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span>

        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;s_sigma_rel&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s_sigma_rel&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials_total</span><span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s_sigma_rel&quot;</span><span class="p">]</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># k cannot be smaller than 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There were shelf heat transfer coefficients &lt; 0. I set them to 0.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_H_shelf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;shelf&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>  <span class="c1"># either a scalar or a vector</span>

    <span class="k">def</span> <span class="nf">_buildHeatflowMatrices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build heatflow matrices.&quot;&quot;&quot;</span>
        <span class="c1"># store which N_vials was used to compute this</span>
        <span class="c1"># (getter method will know to recall this function</span>
        <span class="c1"># if the value changes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NvialsUsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>

        <span class="n">interactionMatrix</span><span class="p">,</span> <span class="n">VIAL_EXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buildInteractionMatrices</span><span class="p">()</span>

        <span class="c1"># compute H_int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_int</span> <span class="o">=</span> <span class="n">interactionMatrix</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;int&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span>

        <span class="c1"># compute H_ext</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_ext</span> <span class="o">=</span> <span class="n">VIAL_EXT</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;ext&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span>

        <span class="c1"># compute H_shelf (potentially depends on rng/seed)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buildShelfHeatFlow</span><span class="p">()</span>

<div class="viewcode-block" id="Snowflake.to_frame"><a class="viewcode-back" href="../../api/ethz_snow.html#ethz_snow.snowflake.Snowflake.to_frame">[docs]</a>    <span class="k">def</span> <span class="nf">to_frame</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n_timeSteps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">250</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Save statistics (and states) as pandas dataframe.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_timeSteps (int, optional): For states a reduced representation is stored.</span>
<span class="sd">                This defines the number of subsamples. Defaults to 250.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Simulation needs to run first.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[pd.DataFrame, Optional[pd.DataFrame]]: The statistics and if available</span>
<span class="sd">                the states over time (both in long form).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulationStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Simulation needs to be run first.&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;vial&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">VIAL_EXT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buildInteractionMatrices</span><span class="p">()</span>

        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">VIAL_EXT</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;corner&quot;</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;edge&quot;</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span>

        <span class="n">stats_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;vial&quot;</span><span class="p">])</span>

        <span class="n">n_storedStates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_storedStates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># to reduce computational cost we limit number of timepoints to n_timeSteps</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="p">[:,</span> <span class="p">::</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_timeSteps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))])</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[::</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_timeSteps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))]</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Time&quot;</span>

            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s2">&quot;temperature&quot;</span><span class="p">,</span> <span class="n">n_storedStates</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="n">n_storedStates</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;vial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">VIAL_EXT</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_storageMask</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;corner&quot;</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;edge&quot;</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span>

            <span class="n">traj_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;vial&quot;</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">traj_df</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">stats_df</span><span class="p">,</span> <span class="n">traj_df</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return string representation of the Snowflake class.</span>

<span class="sd">        A simple indicator of the most important properties of the Snowflake.</span>
<span class="sd">        Returns:</span>
<span class="sd">            str: The Snowflake class string representation giving some basic info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Snowflake([N_vials: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N_vials</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;dt: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="si">}</span><span class="s2">, seed: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="si">}</span><span class="s2">])&quot;</span>
        <span class="p">)</span></div>
</pre></div>

              </div>
              
        
            



<div class='prev-next-bottom'>
    

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
            &copy; Copyright 2021, Leif-Thore Deck, David Ochsenbein.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>